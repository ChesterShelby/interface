При нажатии и отпускании клавиши вызываются следующие методы:

keyPressEvent(self, <event>) — вызывается при нажатии клавиши на клавиатуре. Если клавишу удерживать нажатой,
метод будет вызываться многократно, пока клавишу не отпустят;

keyReleaseEvent(self, <event>) — вызывается при отпускании нажатой ранее клавиши.
Через параметр <event> доступен экземпляр класса QKeyEvent, хранящий дополнительную информацию о событии.
Он поддерживает следующие полезные для нас методы:

key() — возвращает код нажатой клавиши. Пример определения клавиши:
if e.key() == QtCore.Qt.Key_B:
    print("Нажата клавиша <B>")

text() — возвращает текстовое представление введенного символа в кодировке Unicode или пустую строку, если была нажата специальная клавиша;

modifiers() — позволяет определить, какие клавиши-модификаторы (<Shift>, <Ctrl>, <Alt> и др.) были нажаты вместе с клавишей.
Может содержать значения следующих атрибутов из класса QtCore.Qt или их комбинацию:

    • NoModifier — модификаторы не были нажаты;
    • ShiftModifier — была нажата клавиша <Shift>;
    • ControlModifier — была нажата клавиша <Ctrl>;
    • AltModifier — была нажата клавиша <Alt>;
    • MetaModifier — была нажата клавиша <Meta>;
    • KeypadModifier — была нажата любая клавиша на дополнительной клавиатуре;
    • GroupSwitchModifier — была нажата клавиша <Mode_switch> (только в X11).

Вот пример определения, была ли нажата клавиша-модификатор <Shift>:
if e.modifiers() & QtCore.Qt.ShiftModifier:
    print("Нажата клавиша-модификатор <Shift>")

isAutoRepeat() — возвращает True, если событие было вызвано удержанием клавиши нажатой, и False — в противном случае;

matches(<QKeySequence.StandardKey>) — возвращает значение True, если была нажата специальная комбинация клавиш,
соответствующая указанному значению, и False — в противном случае. В качестве значения указываются атрибуты из класса
QKeySequence например, QKeySequence.Copy для комбинации клавиш <Ctrl>+<C> (Копировать):

if e.matches(QtGui.QKeySequence.Copy):
    print("Нажата комбинация <Ctrl>+<C>")

При обработке нажатия клавиш следует учитывать, что:

    1. компонент должен иметь возможность принимать фокус ввода. Некоторые компоненты по умолчанию не могут принимать
    фокус ввода — например, надпись. Чтобы изменить способ получения фокуса, следует воспользоваться методом setFocusPolicy(<Способ>).

    2. чтобы захватить эксклюзивный ввод с клавиатуры, следует воспользоваться методом grabKeyboard(),
    а чтобы освободить ввод — методом releaseKeyboard();

    3. можно перехватить нажатие любых клавиш, кроме клавиши <Tab> и комбинации <Shift>+<Tab>.
    Эти клавиши используются для передачи фокуса следующему и предыдущему компоненту соответственно.
    Перехватить нажатие этих клавиш можно только в методе event(self, <event>);

    4. если событие обработано, следует вызвать метод accept() объекта события.
    Чтобы родительский компонент смог получить событие, вместо метода accept() необходимо вызвать метод ignore().


События мыши обрабатываются не реже, чем события клавиатуры. С помощью специальных методов можно обработать нажатие и
отпускание кнопки мыши, перемещение указателя, вхождение указателя в область компонента и выхода из этой области.
В зависимости от ситуации можно изменить вид указателя — например,
при выполнении длительной операции отобразить указатель в виде песочных часов.
В этом разделе мы рассмотрим изменение вида указателя мыши как для отдельного компонента, так и для всего приложения.

При нажатии и отпускании кнопки мыши вызываются следующие методы:

mousePressEvent(self, <event>) — вызывается при нажатии кнопки мыши;

mouseReleaseEvent(self, <event>) — вызывается при отпускании ранее нажатой кнопки мыши;

mouseDoubleClickEvent(self, <event>) — вызывается при двойном щелчке мышью в области компонента.
Следует учитывать, что двойному щелчку предшествуют другие события.
Последовательность событий при двойном щелчке выглядит так:
    MouseButtonPress
    MouseButtonRelease
    MouseButtonDblClick
    MouseButtonPress
    MouseButtonRelease

Задать интервал двойного щелчка позволяет метод setDoubleClickInterval() класса QApplication,
а получить его текущее значение — метод doubleClickInterval() того же класса.



------------------------------------------------------------------------------------------------------------------------
Для создания искусственных событий применяются следующие статические методы из класса QCoreApplication:

sendEvent(<QObject>, <QEvent>) — немедленно посылает событие компоненту и возвращает результат выполнения обработчика;

postEvent(<QObject>, <QEvent>[, priority=NormalEventPriority]) — добавляет событие в очередь.
Параметром priority можно передать приоритет события, использовав один из следующих атрибутов класса QtCore.Qt:
HighEventPriority (1, высокий приоритет), NormalEventPriority (0, обычный приоритет — значение по умолчанию) и
LowEventPriority (-1, низкий приоритет). Этот метод является потокобезопасным, следовательно,
его можно использовать в многопоточных приложениях для обмена событиями между потоками.
------------------------------------------------------------------------------------------------------------------------
В параметре <QObject> указывается ссылка на объект, которому посылается событие, а в параметре <QEvent> — объект события.
Последний может быть экземпляром как стандартного (например, QMouseEvent), так и пользовательского класса, являющегося наследником
класса QEvent. Вот пример отправки события QEvent.MouseButtonPress компоненту label:

e = QtGui.QMouseEvent(QtCore.QEvent.MouseButtonPress,
QtCore.QPointF(5, 5), QtCore.Qt.LeftButton,
QtCore.Qt.LeftButton, QtCore.Qt.NoModifier)
QtCore.QCoreApplication.sendEvent(self.label, e)

------------------------------------------------------------------------------------------------------------------------
Для отправки пользовательского события необходимо создать класс, наследующий QEvent.
В этом классе следует зарегистрировать пользовательское событие с помощью статического
метода registerEventType() и сохранить идентификатор события в атрибуте класса:

class MyEvent(QtCore.QEvent):
    idType = QtCore.QEvent.registerEventType()
    def __init__(self, data):
        QtCore.QEvent.__init__(self, MyEvent.idType)
        self.data = data
    def get_data(self):
        return self.data

------------------------------------------------------------------------------------------------------------------------

Вот пример отправки события класса MyEvent компоненту label:
QtCore.QCoreApplication.sendEvent(self.label, MyEvent("512"))

Обработать пользовательское событие можно с помощью методов event(self, <event>) или customEvent(self, <event>):

def customEvent(self, e):
    if e.type() == MyEvent.idType:
        self.setText(f"Получены данные: {e.get_data()}")
------------------------------------------------------------------------------------------------------------------------

События можно перехватывать еще до того, как они будут переданы компоненту. Для этого необходимо создать класс,
который является наследником класса QObject, и переопределить в нем метод eventFilter(self, <Объект>, <event>).
Через параметр <Объект> доступна ссылка на компонент, а через параметр <event> — на объект с дополнительной информацией о событии.
Этот объект различен для разных типов событий — так, для события MouseButtonPress объект будет экземпляром класса QMouseEvent,
а для события KeyPress — экземпляром класса QKeyEvent. Из метода eventFilter() следует вернуть значение True,
если событие не должно быть передано дальше, и False — в противном случае.
Вот пример такого класса-фильтра, перехватывающего нажатие клавиши <B>:

class MyFilter(QtCore.QObject):
    def __init__(self, parent=None):
        QtCore.QObject.__init__(self, parent)
    def eventFilter(self, obj, e):
        if e.type() == QtCore.QEvent.KeyPress:
            if e.key() == QtCore.Qt.Key_B:
                print("Событие от клавиши <B> не дойдет до компонента")
                return True
       return QtCore.QObject.eventFilter(self, obj, e)
------------------------------------------------------------------------------------------------------------------------


