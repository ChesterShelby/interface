Ну и конечно же давайте поговорим о оформлении нашего окна. Можно конечно указывать и напрямую цвет компонентов,
но желательно использовать таблицу стилей CSS. Она позволяет нам быть намного гибче.
Для работы с CSS существует метод setStyleSheet().

Метод setStyleSheet() поддерживается классами QWidget (и всеми его подклассами) и QApplication.
Следовательно, его можно вызвать у:

    самого приложения — тогда заданные в таблице стилей параметры оформления будут применены ко всем элементам управления всех окон приложения;
    отдельного окна — тогда эти параметры будут действовать в пределах данного окна;
    отдельного элемента управления — тогда они будут действовать только на этот элемент управления


При указании таблицы стилей у приложения и окна можно использовать стандартный CSS формат объявления стилей:
<Селектор> {<Определение стилей>}

<Селектор> записывается в следующем формате:
<Основной селектор>[<Дополнительный селектор>][<Псевдокласс>][<Псевдоселектор>]
Параметр <Основной селектор> указывает на класс элемента управления. Его можно указать в одном из следующих форматов:
    * (звездочка) — указывает на все элементы управления (универсальный селектор). Например,
    так можно задать для всех элементов управления зеленый цвет текста:
    * {color: green;}

<Класс> — указывает на элементы управления, относящиеся к заданному <Классу> и его подклассам.
Задание красного цвета текста для всех элементов управления, относящихся к классу QAbstractButton и его подклассам,
т. е. для командных кнопок, флажков и переключателей, осуществляется так:

QAbstractButton {color: red;}


.<Класс> — указывает только на элементы управления, относящиеся к заданному <Классу>, но не к его подклассам.
Указание полужирного шрифта для всех элементов управления, относящихся к классу QPushButton (командных кнопок),
но не для его подклассов, осуществляется так:

.QPushButton {font-weight: bold;}


Параметр <Дополнительный селектор> задает дополнительные параметры элемента управления. Его форматы:
[<Свойство>="<Значение>"] — указанное <Свойство> элемента управления должно иметь заданное <Значение>.
Так мы задаем полужирный шрифт для кнопки, чье свойство default имеет значение true, т. е. для кнопки по умолчанию:

QPushButton[default="true"] {font-weight: bold;}


#<Имя> — указывает на элемент управления, для которого было задано <Имя>.
<Имя> можно задать вызовом у элемента управления метода setObjectName(<Имя>), а получить — вызовом метода objectName().
Так выполняется указание красного цвета текста для кнопки с именем btnRed:

QPushButton#btnRed {color: red;}


Параметр <Псевдокласс> указывает на отдельную составную часть сложного элемента управления.
Он записывается в формате ::<Обозначение составной части>. Вот пример указания графического изображения
для кнопки разворачивания раскрывающегося списка (обозначение этой составной части — down-arrow):

QComboBox::down-arrow {image: url(arrow.png);}


Параметр <Псевдоселектор> указывает на состояние элемента управления (должна ли быть кнопка нажата,
должен ли флажок быть установленным и т. п.). Он может быть записан в двух форматах:

    :<Обозначение состояния> — элемент управления должен находиться в указанном состоянии.
    Вот пример указания белого цвета фона для кнопки, когда она нажата (это состояние имеет обозначение pressed):

    QPushButton:pressed {background-color: white;}


    :!<Обозначение состояния> — элемент управления должен находиться в любом состоянии, кроме указанного.
    Вот пример указания желтого цвета фона для кнопки, когда она не нажата:

    QPushButton:!pressed {background-color: yellow;}


Можно указать сразу несколько псевдоселекторов, расположив их непосредственно друг за другом —
тогда селектор будет указывать на элемент управления, находящийся одновременно во всех состояниях,
которые обозначены этими селекторами. Вот пример указания черного цвета фона и белого цвета текста для кнопки,
которая нажата и над которой находится курсор мыши (обозначение — hover):

QPushButton:pressed:hover {color: white; background-color: black;}


Если нужно указать стиль для элемента управления, вложенного в другой элемент управления,
применяется следующий формат указания селектора:

<Селектор "внешнего" элемента><Разделитель><Селектор вложенного элемента>

Поддерживаются два варианта параметра <Разделитель>:

пробел — <Вложенный элемент> не обязательно должен быть вложен непосредственно во <"Внешний">.
Так мы указываем зеленый цвет фона для всех надписей (QLabel), вложенных в группу (QGroupBox) и вложенные в нее элементы:

QGroupBox QLabel {background-color: green;}


> — <Вложенный элемент> обязательно должен быть вложен непосредственно во <"Внешний">.
Так мы укажем синий цвет текста для всех надписей, непосредственно вложенных в группу:

QGroupBox>QLabel {color: blue;}


В стиле можно указать сразу несколько селекторов, записав их через запятую — тогда стиль будет применен к элементам
управления, на которые указывают эти селекторы. Вот пример задания зеленого цвета фона для кнопок и надписей:

QLabel, QPushButton {background-color: green;}


В CSS элементы страницы наследуют параметры оформления от их родителей. Но в PyQt это не так. Скажем,
если мы укажем для группы красный цвет текста:

app.setStyleSheet("QGroupBox {color: red;}")


вложенные в эту группу элементы не унаследуют его и будут иметь цвет текста, заданный по умолчанию.
Нам придется задать для них нужный цвет явно:

app.setStyleSheet("QGroupBox, QGroupBox * {color: red;}")


В PyQt поддерживается возможность указать библиотеке, что все элементы-потомки должны наследовать параметры оформления
у родителя. Для этого достаточно вызвать у класса QCoreApplication статический метод setAttribute,
передав ему в качестве первого параметра значение атрибута AA_UseStyleSheetPropagationInWidgetStyles класса QtCore.Qt,
а в качестве второго параметра — значение True:

QtCore.QCoreApplication.setAttribute(
QtCore.Qt.AA_UseStyleSheetPropagationInWidgetStyles, True)


Чтобы отключить такую возможность, достаточно вызвать этот метод еще раз, указав в нем вторым параметром False.
И, наконец, при вызове метода setStyleSheet() у элемента управления, для которого следует задать таблицу стилей,
в последней не указываются ни селектор, ни фигурные скобки — они просто не нужны. Отметим, что в случае PyQt, как и в CSS,
также действуют правила каскадности. Так, таблица стилей, заданная для окна, имеет больший приоритет, нежели таковая,
указанная для приложения, а стиль, что был задан для элемента управления, имеет наивысший приоритет.
Помимо этого, более специфические стили имеют больший приоритет, чем менее специфические;
так, стиль с селектором, в чей состав входит имя элемента управления, перекроет стиль с селектором любого другого типа.
